---
title: "drft"
format: html
editor: visual
---



# Introduction

Why do some regimes end in coups while others persist? This project takes a **design-based causal** approach to a narrow, testable question using the [**Varieties of Democracy (V-Dem)**](https://www.v-dem.net/) country–year panel (global coverage; annual updates since the eighteenth century).

**Research question.** *Do coup attempts in year* $t$ *raise the probability that the regime ends via a coup in year* $t{+}1$?

**Unit of analysis.** Country–year.

**One-sentence design.** To avoid temporal leakage, all predictors are measured at year $t$ and the outcome at year $t{+}1$; we model the **marginal** probability of a coup termination next year for **all** country–years, rather than conditioning on the event that a regime ends.

**Key variables.**
- **Treatment** $A_t$: indicator that at least one coup attempt is recorded in year $t$ (from V-Dem `e_pt_coup_attempts`).
- **Outcome** $Y^*_{t+1}$: indicator that the regime **ends via a coup** in year $t{+}1$; we code $Y^*_{t+1}=1$ when `v2regendtype_{t+1} ∈ {0,1,2}` (military coup, non-military coup, self-coup) and $0$ for all other non-missing codes, including “still exists” (`13`).  
  *Rationale:* not conditioning on “the regime ends” avoids a collider between many time-varying forces (e.g., civil war, mass protest, elite splits) and the type of termination.

**Identification in brief.** We block back-door paths by adjusting for:
1) **Country heterogeneity** $U_i$ (political culture, state capacity, elite organization) via country fixed effects or a country random intercept;
2) **Period shocks/trends** $W_t$ (e.g., the long-run decline in coups) via year fixed effects; and
3) A **time-varying confounder** $C_t$ (civil war, from V-Dem `e_civil_war`) that plausibly affects both attempts and coup terminations.  
Under (i) temporal ordering (predictors at $t$, outcomes at $t{+}1$), (ii) conditional ignorability given $\{U_i,W_t,C_t\}$, (iii) overlap (within-country variation in $A_t$), and (iv) SUTVA, our contrasts identify a **conditional average treatment effect**.

**Estimand.** The average treatment effect of a coup attempt in year $t$ on the probability of a coup termination in year $t{+}1$:

$$
\mathrm{ATE} \;=\; \mathbb{E}\!\left[\,Y^*_{t+1}(1) - Y^*_{t+1}(0)\,\right].
$$

**Estimators and reporting.** We fit (a) a logit with country and year fixed effects and clustered standard errors, and (b) a mixed-effects logit with a country random intercept and year fixed effects; we then extend (b) by adding civil war. For interpretability we report **odds ratios (OR)** and **average risk differences** via **g-computation** (predict $P(Y^*_{t+1}=1)$ for the same observations under $A_t{=}1$ and $A_t{=}0$, then average the difference).

**Roadmap.** We first describe how regimes end in V-Dem to set priors, then construct $Y^*_{t+1}$ and $A_t$, show an unadjusted check, and finally present the fixed-effects and mixed-effects estimates with and without the civil-war adjustment.






-   `histname`: historical label of the political entity; used to track within-country regime continuity.
-   `v2regendtype`: code describing **how** a regime ends in a year (e.g., military coup `0`, non-military coup `1`, self-coup `2`, “still exists” `13`).
-   `e_pt_coup_attempts`: count of recorded coup attempts in the year (available for the post-1950 period).
-   `e_civil_war`: indicator of civil war in the year (time-varying confounder).
-   `country_id`, `year`: panel identifiers.

We keep observations where these inputs are available and align predictors to year (t) and outcomes to year (t{+}1).

## Measurement and construction

1.  **Within-country change flag.** Standardize `histname` (lowercase, trim whitespace) and mark a change when it differs from the previous year within the same country. This is a descriptive check of regime churn.
2.  **Next-year end type.** Create `regend_t1 = lead(v2regendtype, 1)` to align end types to (t{+}1).
3.  **Outcome.** Define (Y\^\*\_{t+1}=1) if `regend_t1 ∈ {0,1,2}` (ends via a coup) and (0) for all other non-missing codes, including `13` “still exists.” This avoids conditioning on the event of ending.
4.  **Treatment.** Define (A_t=1) if `e_pt_coup_attempts > 0`, else (0). We restrict to years where attempts are recorded (mainly 1950+).
5.  **Checks.** Report the base rate (\mathbb{E}\[Y\^\*\_{t+1}\]) and the split of (A_t\in{0,1}) to verify rarity and overlap.

## Design diagnostics (descriptive priors)

Before modeling, we tabulate the distribution of `v2regendtype` overall and among rows that precede a `histname` change. These tables are **descriptive priors** only (e.g., coups are rare relative to other endings). We also show an unadjusted split of (Y\^\*\_{t+1}) by (A_t) to illustrate the raw association that the causal design will later adjust.

## Estimation strategy

We target the conditional average treatment effect of (A_t) on (Y\^\*\_{t+1}) under temporal ordering, ignorability given ({U_i,W_t,C_t}), overlap, and SUTVA. Concretely:

-   **Model 1 (FE logit).** Logit with **country fixed effects** and **year fixed effects**; cluster standard errors by country.
-   **Model 2 (RE logit + year FE).** Mixed-effects logit with a **country random intercept** and **year fixed effects** (partial pooling across countries).
-   **Model 3 (+ civil war).** Extend Model 2 by adding `e_civil_war` as a time-varying confounder (C_t).

For interpretability we report (i) **odds ratios (OR)** for `attempt`, with 95% CIs; and (ii) **average risk differences** via **g-computation**: predict (P(Y\^\*\_{t+1}=1)) for each row under (A_t{=}1) and (A_t{=}0), then average the difference. If high-dimensional FE causes (quasi-)separation, we note a penalized alternative (e.g., Firth logit or `glmmTMB`) in the Appendix.

## Scope, interpretation, and limitations

Effects are **short-run** ((t \rightarrow t{+}1)) and **conditional** on the adjustment set. They do not capture long-run dynamics or feedback between attempts and conflict. Uncertainty is non-trivial because both coup attempts and coup terminations are rare. Identification assumes no important time-varying confounders beyond country/year effects and civil war, and consistent coding in V-Dem.

## Roadmap

1)  Describe end-type frequencies (descriptive priors).\
2)  Construct (Y\^\*\_{t+1}) and (A_t); show an unadjusted split.\
3)  Estimate the FE logit and report OR and g-computed risk difference.\
4)  Replicate with a random-intercept logit (year FE), then add civil war.\
5)  Summarize the treatment effect and discuss robustness and limitations.






This project uses causal inference to move from descriptive co-movement to credible claims about causes of macro-political change. We study **regime change** through a design that aligns temporal information and guards against post-treatment conditioning. The empirical setting is the **Varieties of Democracy (V-Dem)** project, one of the most comprehensive, annually updated cross-national data sets on regimes and institutions (covering most countries since the 18th century).<br>

Data: <https://github.com/vdeminstitute/vdemdata>

**Research question:** *Which conditions make it more (or less) likely that a country experiences a regime change—and, in particular, a regime change that ends via a coup?*

**Unit of analysis:** Country–year.

**Design choice:** To prevent temporal leakage, predictors come from year (t); outcomes refer to year (t+1). We treat “coup termination next year” as the outcome and study whether **coup attempts in year (t)** raise that risk after adjusting for country heterogeneity and time-varying confounders (e.g., civil war). This lets us compare like with like—changes **within countries over time**, not just differences across countries.


The analysis is guided by four core research questions:

RQ: What kinds of factors cause a country to undergo a regime change?

We study macro-political transformations with a causal lens. The unit is country–year. To avoid temporal leakage, the outcome is whether a regime change occurs in year t+1 given information available by the end of year t. We use V-Dem for yearly indicators. Conceptually, we posit that shocks (economic, conflict), mobilization (protest), repression, and institutional constraints shape the hazard of regime change, with possible unobserved country-level traits.

# RQ: What kinds of factors cause a country to undergo a regime change?

This section explores the historical predictors of regime change using V-Dem's country-year panel data, covering over 200 years and nearly all sovereign states. We operationalize regime change based on transitions in the `histname` field and use logistic regression to assess whether various political, structural, and conflict-related variables can significantly predict the likelihood of a regime shift.

## Import Data and Load Packages

```{r}
# Install V-Dem data package:
# install.packages("devtools")
# devtools::install_github("vdeminstitute/vdemdata")

library(vdemdata)
library(tidyverse)
library(effects)
library(stringr)
```

V-Dem includes a variable, v2reginfo, that labels distinct historical phases within the same political entity (e.g., “Soviet Russia,” “USSR under Stalin,” “Post-Stalin USSR”) as separate regimes. While this fine-grained coding is valuable for phase-typed institutional histories, in this study I adopt a broader conception of “regime” tied to the persistence of the overarching political entity. Concretely, I operationalize regime change as a within-country shift in histname across adjacent years. This choice treats leader-centered or intra-regime episodes (that v2reginfo may separate) as continuity rather than change, while recognizing foundational transformations that coincide with historical-state redefinitions (e.g., mergers, dissolutions, refoundings). I report sensitivity analyses that compare this histname-based indicator to a v2reginfo-based alternative to gauge how inferences depend on the operationalization.

## Create Regime Change Variable

We define regime change as a change in the `histname` field within a country across years.

```{r}
vdem_1 <- vdem |> 
  arrange(country_id, year) |> 
  group_by(country_id) |> 
  mutate(regime_change = if_else(histname != lag(histname), 1, 0, missing = 0)) |> 
  ungroup()

regime_transitions <- vdem_1 |> 
  arrange(country_id, year) |> 
  group_by(country_id) |> 
  mutate(
    previous_histname = lag(histname),
    current_histname = histname
  ) |> 
  filter(regime_change == 1) |> 
  select(country_id, country_name, year, previous_histname, current_histname) |> 
  ungroup()


vdem_1 <- vdem_1 %>%
  group_by(country_name) %>%
  arrange(year) %>%
  mutate(
    regime_change_check = if_else(
      lag(v2reginfo) != v2reginfo,
      1, 0
    ),
    regime_change_check = replace_na(regime_change_check, 1)  
  )

table(vdem_1$regime_change, vdem_1$regime_change_check)

```

## Check end type

```{r}
# 1) 代码-标签对照表（来自代码手册）
regend_labels <- tibble::tibble(
  v2regendtype = 0:13,
  label = c(
    "Military coup d’état",
    "Coup by non-military groups",
    "Self-coup by sitting leader",
    "Assassination (not a coup)",
    "Natural death of leader",
    "Loss in civil war",
    "Loss in inter-state war",
    "Foreign intervention (non interstate-loss)",
    "Popular uprising",
    "Liberalization/democratization w/ regime guidance",
    "Other intentional transformation (excl. liberalization)",
    "Liberalization/democratization w/o regime guidance",
    "Other process (not 1–11)",
    "Regime still exists"
  )
)

# 2) 取出变量并合并标签
df_end <- vdem %>%
  select(country_id, country_name, year, v2regendtype) %>%
  mutate(v2regendtype = as.integer(v2regendtype)) %>%
  left_join(regend_labels, by = "v2regendtype")

# 3) 分布（包含“仍在进行”的 13）
dist_all <- df_end %>%
  filter(!is.na(v2regendtype)) %>%
  count(v2regendtype, label, name = "n") %>%
  mutate(pct = n / sum(n)) %>%
  arrange(desc(n))

dist_all

ggplot(dist_all,
       aes(x = fct_reorder(str_trunc(label, 60), n), y = n)) +
  geom_col() +
  coord_flip() +
  labs(title = "v2regendtype: distribution (including 13 = regime still exists)",
       x = NULL, y = "Count") +
  theme_minimal(base_size = 12)

# 4) 仅统计“政体已结束”的类型（0–12）
dist_finished <- df_end %>%
  filter(!is.na(v2regendtype), v2regendtype %in% 0:12) %>%
  count(v2regendtype, label, name = "n") %>%
  mutate(pct = n / sum(n)) %>%
  arrange(desc(n))

dist_finished

ggplot(dist_finished,
       aes(x = fct_reorder(str_trunc(label, 60), n), y = n)) +
  geom_col() +
  coord_flip() +
  labs(title = "v2regendtype: distribution among ended regimes (0–12)",
       x = NULL, y = "Count") +
  theme_minimal(base_size = 12)


```

## Naive Logit Model with Political Indicators

We first test a simple model using three high-level indices:
- `v2x_corr`: Control of corruption
- `v2x_polyarchy`: Electoral democracy index
- `v2x_freexp_altinf`: Freedom of alternative sources of information

```{r}
vdem_model <- vdem_1 |> 
  arrange(country_id, year) |> 
  group_by(country_id) |> 
  mutate(
    v2x_corr_lag1 = lag(v2x_corr, 1),
    v2x_polyarchy_lag1 = lag(v2x_polyarchy, 1),
    v2x_freexp_altinf_lag1 = lag(v2x_freexp_altinf, 1)
  ) |> 
  ungroup()

model1 <- glm(regime_change ~ v2x_corr_lag1 + v2x_polyarchy_lag1 + v2x_freexp_altinf_lag1,
              data = vdem_model,
              family = binomial(link = "logit"))
summary(model1)
```

## Structural and Background Factors Model

We expand the model to include structural and conflict variables:
- `e_gdppc`: GDP per capita
- `e_peaveduc`: Education level (15+)
- `e_civil_war`: Civil war dummy
- `e_pt_coup`: Number of coup attempts

```{r}
vdem_model1 <- vdem_model |>
  arrange(country_id, year) |>
  group_by(country_id) |>
  mutate(
    e_gdppc_lag1 = lag(e_gdppc),
    e_peaveduc_lag1 = lag(e_peaveduc),
    e_civil_war_lag1 = lag(e_civil_war),
    e_pt_coup_lag1 = lag(e_pt_coup),
    e_total_oil_income_pc_lag1 = lag(e_total_oil_income_pc)
  ) |>
  ungroup()

model_bg <- glm(regime_change ~ 
                  v2x_polyarchy_lag1 + 
                  e_gdppc_lag1 + 
                  e_civil_war_lag1 + 
                  e_pt_coup_lag1 + 
                  e_peaveduc_lag1,
                data = vdem_model1,
                family = binomial(link = "logit"))
summary(model_bg)
```

## Visualizing Marginal Effects

```{r}
plot(allEffects(model1))
plot(allEffects(model_bg))
```

## Interpretation

Initial results suggest that lower levels of electoral democracy and active civil conflict significantly increase the likelihood of regime change. However, economic indicators such as GDP and education do not appear to have strong predictive power in this specification.

---

# RQ2: What factors influence the establishment of communist regimes?

To answer this question, we need to define "communist regimes" first. Is "communist" "socialist"? Or it contains other potential meanings? This is the mischievous Mike in this study.


```{r}

vdem$v2reginfo
```


```{r}

regime_transitions |>
  filter(str_detect(current_histname, "People's Republic") |
         str_detect(current_histname, "Socialist Republic") |
         str_detect(current_histname, "Socialist") |
         str_detect(current_histname, "Soviet") |
         str_detect(current_histname, "Democratic People's Republic")) |>
  arrange(year)


communist_keywords <- c("People's Republic", "Socialist Republic", "Socialist", "Soviet", "Democratic People's Republic", "People's Democratic Republic")

regime_transitions |>
  filter(str_detect(current_histname, str_c(communist_keywords, collapse = "|"))) |>
  arrange(country_id, year) |>
  group_by(country_id) |>
  slice_min(year, n = 1) |> 
  ungroup() |>
  arrange(year)

```



Georgia Soviet Socialist Republic缺失政体建立前后时期的数据


**Next Steps**:
We will next turn to more specific questions:

- What factors explain the formation of communist regimes?
- What causes communist regimes to collapse?
- What drives capitalist regimes to transition into communism?

We will construct new binary regime-type indicators to address these questions in subsequent models.


# RQ3: What factors contribute to the collapse of communist regimes?


# RQ4: What factors explain the long-term survival of the remaining communist regimes (China, Cuba, Laos, North Korea, and Vietnam)?





# EDA

## Test function in `vdemdata` package

```{r}
vdemdata::plot_indicator("v2msuffrage")

# Plot V-Dem indicators liberal democracy and egalitarian democracy
# for Sweden and Germany between 1912 and 2000.

plot_indicator(indicator=c( "v2x_egaldem", "v2x_libdem"), countries = c("Germany", "Sweden"),
                     min_year = 1912, max_year = 2000)
```

## What country do we have?

```{r}
unique(vdem$country_name)
```


Pick out German, Russia and China

```{r}
selected_data <- vdem |>
  filter(country_text_id %in% c("DEU", "RUS", "CHN")) |>
  select(where(~ !any(is.na(.))))

```

```{r}

selected_data |>
  group_by(country_text_id) |>
  summarize(
    years_available = sum(!is.na(v2csreprss)),
    year_min = min(year[!is.na(v2csreprss)]),
    year_max = max(year[!is.na(v2csreprss)])
  )


```

```{r}
ggplot(selected_data, aes(x = year, y = v2csreprss, color = country_text_id)) +
  geom_point() +
  labs(
    title = "CSO Repression Over Time (V-Dem v2csreprss)",
    x = "Year",
    y = "Civil Society Repression",
    color = "Country"
  ) +
  scale_color_manual(
    values = c("DEU" = "black", "RUS" = "red", "CHN" = "blue"),
    labels = c("Germany", "Russia", "China")
  ) +
  theme_minimal()


```



# MVP


```{r}
#| label: prep-episodes
#| warning: false
library(dplyr)
library(stringr)
# 假设你已经有 vdem 数据框（vdemdata 包或你自己的读取方式）
# 必需列：country_id, country_name, year, histname, v2regendtype,
#        e_civil_war, e_miinteco, e_miinterc, e_pt_coup, e_pt_coup_attempts

# 1) episode 划分：histname 变化即新政体
vdem_ep <- vdem %>%
  arrange(country_id, year) %>%
  group_by(country_id) %>%
  mutate(ep_break = if_else(histname != lag(histname), 1L, 0L, missing = 1L),
         regime_ep = cumsum(ep_break)) %>%
  ungroup()

# 2) 每个 episode 的结束类型（该政体最后一年的 v2regendtype）
ep_summary <- vdem_ep %>%
  group_by(country_id, regime_ep) %>%
  summarize(
    # 不再带 country_name，避免重名
    histname_ep  = last(histname),
    year_start   = min(year, na.rm = TRUE),
    year_end     = max(year, na.rm = TRUE),
    end_type_raw = v2regendtype[which.max(year)],
    .groups = "drop"
  )

# 3) 合并类别：把 0–12 合为若干“机制桶”，13=仍然存在
collapse_endtype <- function(x){
  dplyr::case_when(
    x %in% c(0,1,2,3) ~ "coup/assassination", # 政变/刺杀/自我政变
    x %in% c(5,6,7)   ~ "war_loss/foreign_intervention", # 内战失败/对外战败/外部干预
    x %in% c(8)       ~ "popular_uprising", # 群众起义
    x %in% c(9,11)    ~ "liberalization/democratization",# 自由化/民主化
    x %in% c(10,12)   ~ "other_transformation",          # 其他制度性转型
    x %in% c(4)       ~ "leader_natural_death",          # 领袖自然死亡（可选）
    x %in% c(13)      ~ "still_exists",                  # 仍在进行
    TRUE              ~ NA_character_
  )
}
ep_summary <- ep_summary %>%
  mutate(end_bucket = collapse_endtype(end_type_raw))

# 4) 回填到每年，用于构造滞后自变量（并标注episode内时长）
vdem_ep <- vdem_ep %>%
  left_join(ep_summary, by = c("country_id","regime_ep")) %>%
  group_by(country_id, regime_ep) %>%
  mutate(
    t_in_ep = year - min(year) + 1L,
    is_last = year == max(year),
    # 该年是否真正结束（排除13）
    end_any = as.integer(is_last & !is.na(end_bucket) & end_bucket != "still_exists")
  ) %>%
  ungroup()

# 5) 构造自变量（滞后1年）
panel <- vdem_ep %>%
  arrange(country_id, year) %>%
  group_by(country_id) %>%
  mutate(
    civil_lag1   = lag(e_civil_war, 1),
    intl_lag1    = lag(e_miinteco, 1),      # 国际武装冲突
    internal_lag1= lag(e_miinterc, 1),      # 国内武装冲突
    coup_lag1    = lag(e_pt_coup, 1),
    attempts_lag1= lag(e_pt_coup_attempts, 1)
  ) %>%
  ungroup()

# 6) 只保留“结束那一年”的观测来做多项分类（预测*哪种*结束方式）
train_df <- panel %>%
  filter(is_last, !is.na(end_bucket), end_bucket != "still_exists") %>%
  select(country_id, country_name, year, end_bucket,
         civil_lag1, intl_lag1, internal_lag1, coup_lag1, attempts_lag1) %>%
  tidyr::drop_na()

# 保存类别基准顺序（把最高频类别放前面作为 baseline）
tab <- sort(table(train_df$end_bucket), decreasing = TRUE)
cat_levels <- names(tab)
train_df$end_bucket <- factor(train_df$end_bucket, levels = cat_levels)

# 先验用的历史分布（经验频率：所有年所有国家）
prior_counts <- as.numeric(tab)
prior_probs  <- prior_counts / sum(prior_counts)

# 写到磁盘（给 PyMC 用）
write.csv(train_df, "ep_model.csv", row.names = FALSE)
write.csv(data.frame(cat = cat_levels,
                     count = prior_counts,
                     prob  = prior_probs),
          "ep_prior.csv", row.names = FALSE)


```
```{r}
library(reticulate)

# 确认当前使用的 Python（你截图显示的是 uv 虚拟环境）
reticulate::py_config()

# 直接在“当前环境”里装需要的包
# 如果你已经有了 numpy 2.x，但后面某些包报兼容问题，
# 可以把 numpy 固定到 1.26.4（见下方注释行）
reticulate::py_install(
  c(
    "pandas",
    "pymc",
    "arviz",
    "matplotlib",
    "scipy",
    "pytensor",
    "aesara"
    # ,"numpy==1.26.4"  # 只有出现兼容问题时再解注释降级
  ),
  pip = TRUE
)

# 装完测试
reticulate::py_run_string("
import sys
print(sys.version)
import numpy as np, pandas as pd
import pymc as pm, arviz as az
print('numpy', np.__version__)
print('pandas', pd.__version__)
print('pymc', pm.__version__)
print('arviz', az.__version__)
")


```

```{python}

#| label: pymc-fit
#| engine: python
#| warning: false
import numpy as np
import pandas as pd
import pymc as pm
import pytensor.tensor as pt
import arviz as az

# 1) 读取 R 导出的两份数据
df  = pd.read_csv("ep_model.csv")     # 每个 episode 的“结束那一年” + 滞后自变量
pri = pd.read_csv("ep_prior.csv")     # 从历史频率来的“信息性先验”

# 2) 类别与先验
cats     = list(pri["cat"])
K        = len(cats)
prior_p  = pri["prob"].values.astype("float64")   # 历史分布（经验概率）
baseline = cats[0]                                # 最高频类别作为 baseline（与 prior.csv 顺序一致）

# 3) y -> 0..K-1
cat_to_idx = {c:i for i,c in enumerate(cats)}
y = df["end_bucket"].map(cat_to_idx).values
# 若数据里有没出现在 cats 中的类别，会得到 NaN；这里保护一下
mask = ~np.isnan(y)
y = y[mask].astype("int64")

# 4) 设计矩阵（标准化；并与 y 对齐）
X_cols = ["civil_lag1","intl_lag1","internal_lag1","coup_lag1","attempts_lag1"]
X_raw = df.loc[mask, X_cols].astype(float).values
X = (X_raw - X_raw.mean(axis=0)) / X_raw.std(axis=0)
X = X.astype(pm.floatX)     # 与后端 dtype 对齐

N, P = X.shape

# 5) 先验中心：将经验概率转为相对 baseline 的 log-odds 中心
log_p = np.log(prior_p + 1e-12)           # 数值稳定
base_idx = 0
prior_alpha_center = (log_p[1:] - log_p[base_idx]).astype(pm.floatX)   # 对 K-1 个非基类

# 兼容：老版本用 pm.Data，新版本用 pm.MutableData
Data = getattr(pm, "MutableData", pm.Data)

with pm.Model() as mdl:
    Xd = Data("X", X)
    yd = Data("y_obs", y)

    alpha = pm.Normal("alpha", mu=prior_alpha_center, sigma=0.75, shape=K-1)
    beta  = pm.Normal("beta",  mu=0.0, sigma=1.0,    shape=(P, K-1))

    linpred_nb = pt.dot(Xd, beta) + alpha
    linpred = pt.concatenate([pt.zeros((N,1), dtype=linpred_nb.dtype), linpred_nb], axis=1)

    # 两种写法二选一 —— 你的版本如果支持，用 logit_p 更稳：
    # y_like = pm.Categorical("y", logit_p=linpred, observed=yd)
    p = pm.math.softmax(linpred)
    y_like = pm.Categorical("y", p=p, observed=yd)

    idata = pm.sample(2000, tune=2000, chains=4, target_accept=0.9, random_seed=5650)


# 12) 汇总
az.summary(idata, var_names=["alpha","beta"], round_to=3)


```

```{python}
print(np.unique(y))
print(np.min(y), np.max(y))
print(np.isnan(y).sum())
print(np.isnan(X).sum(axis=0))      # 每列 NaN 个数
print(X.std(axis=0))                # 零方差会出问题
```
```{python}

# 1) 温和化先验（防止极端概率导致 log-odds 太大）
eps = 1e-4
prior_p = np.clip(prior_p, eps, 1)
prior_p = prior_p / prior_p.sum()

log_p = np.log(prior_p)
base_idx = 0                          # 把第 1 类当 baseline
prior_alpha_center = log_p[1:] - log_p[base_idx]
print("prior_p:", prior_p.round(4))
print("prior_alpha_center:", prior_alpha_center.round(3))

# 2) 建模：pm.Data + 稳定 softmax + ADVI 初始化
N, P = X.shape
K     = len(prior_p)

with pm.Model() as mdl:
    Xd = pm.Data("X", X)
    yd = pm.Data("y_obs", y)

    # 截距（K-1 个，基类的截距为 0）
    alpha = pm.Normal("alpha", mu=prior_alpha_center, sigma=2.0, shape=K-1)
    # 每个非基类一组系数
    beta  = pm.Normal("beta",  mu=0.0, sigma=2.0, shape=(P, K-1))

    # 线性预测
    linpred_nb = pt.dot(Xd, beta) + alpha                     # (N, K-1)
    linpred    = pt.concatenate([pt.zeros((N,1), dtype=linpred_nb.dtype), linpred_nb], axis=1)

    # 数值稳定的 softmax（减去每行最大值）
    linpred_shift = linpred - pt.max(linpred, axis=1, keepdims=True)
    p = pm.math.softmax(linpred_shift)

    y_like = pm.Categorical("y", p=p, observed=yd)

    # 用 ADVI 找初值
    approx = pm.fit(10_000, method="advi", progressbar=True)
    idata  = pm.sample(
        1500, tune=1500, chains=2, target_accept=0.9,
        initvals=approx.sample(1), progressbar=True
    )

```

```{python}
import numpy as np
import pandas as pd
import pymc as pm
import arviz as az

# 读入你刚刚导出的两份 csv
df  = pd.read_csv("ep_model.csv")     # 有 end_bucket
pri = pd.read_csv("ep_prior.csv")     # 有 cat, prob

# 类别顺序与映射（确保和 ep_prior 一致）
cats = list(pri["cat"])
cat_to_idx = {c:i for i,c in enumerate(cats)}
y = df["end_bucket"].map(cat_to_idx).to_numpy()

# Dirichlet 先验强度（相当于伪计数）：可以调大/调小
strength = 50.0
alpha = strength * pri["prob"].to_numpy() + 1e-6   # 防止 0

with pm.Model() as m0:
    theta = pm.Dirichlet("theta", a=alpha)
    y_obs = pm.Categorical("y", p=theta, observed=y)
    idata0 = pm.sample(2000, tune=2000, chains=2, target_accept=0.9, random_seed=5650)

print(az.summary(idata0, var_names=["theta"]))

```

```{python}
# 如果你之前已经建好了 baseline 模型，就直接用你那个变量名
# 这里给一个最小可复现的 baseline 模型（只有 Dirichlet + Categorical）

import numpy as np
import pandas as pd
import pymc as pm

# 读你之前导出的 y（也可以复用内存里的 y）
df = pd.read_csv("ep_model.csv")            # 确保这个文件在工作目录
cats = sorted(df["end_bucket"].dropna().unique())
cat_to_idx = {c:i for i,c in enumerate(cats)}
y = df["end_bucket"].map(cat_to_idx).values

K = len(cats)

with pm.Model() as mdl_baseline:
    theta = pm.Dirichlet("theta", a=np.ones(K))
    y_obs = pm.Categorical("y", p=theta, observed=y)

# ⭐ 关键：用 model_to_graphviz() 生成 PGM
g = pm.model_to_graphviz(mdl_baseline)
g  # 在 RStudio/Quarto 里会内联显示

```

```{python}
import sys, platform
print("PY:", sys.executable)
print("VER:", platform.python_version())

```





结果（控制国家/年份与内战）：在加入国家随机截距与年份固定效应并控制当年是否内战后，attempt=1 对“次年是否以政变方式结束”的影响为 OR=0.714（95% CI：0.101–5.068），对应的平均风险差约 −2.36 个百分点。这与不控制时的强正相关（+24.5pp）方向相反，说明先前的关联主要来自国家/年份之间的系统性差异；在同一国家内部、同一时间背景下比较，当年出现政变企图并不显著提高次年政变收场的概率，估计甚至略偏负。 内战系数方向为正（OR≈1.39），符合直觉，但由于内战年份较少（约 5%），不确定性较大。




# Appendix

条件版解析（两组的 prior/obs/post）

```{python}
#| label: py-conditional-analytic
import numpy as np

y = np.array(r.y, dtype="int64")
x = np.array(r.x, dtype="int64")
alpha = float(r.alpha); beta = float(r.beta)

def stats(mask, name):
    y_g = y[mask]; n = len(y_g); s = int(y_g.sum())
    prior_mean = alpha/(alpha+beta)
    post_mean  = (alpha + s)/(alpha + beta + n)   # Beta–Bernoulli 共轭后验均值
    obs_mean   = y_g.mean() if n>0 else np.nan
    return {"group": name, "n": n,
            "prior_mean": round(float(prior_mean),4),
            "obs_mean":   round(float(obs_mean),4),
            "post_mean":  round(float(post_mean),4)}

out = [stats(x==1, "attempt=1"), stats(x==0, "attempt=0")]
print(out)
print({"posterior_diff": round(out[0]["post_mean"] - out[1]["post_mean"], 4)})


```

我们用 Beta 共轭的后验抽样，给两组各自的 95% 区间，并给出“差值\>0 的后验概率”。把下面这段 放在你刚打印两组均值的 Python 块后面 即可：

```{python}
#| label: py-conditional-intervals
import numpy as np
rng = np.random.default_rng(0)

y = np.array(r.y, dtype="int64")
x = np.array(r.x, dtype="int64")
alpha = float(r.alpha); beta = float(r.beta)

def post_draws(mask, size=50000):
    y_g = y[mask]
    n = len(y_g); s = int(y_g.sum())
    a = alpha + s
    b = beta  + (n - s)
    return rng.beta(a, b, size=size)

d1 = post_draws(x==1)   # attempt=1
d0 = post_draws(x==0)   # attempt=0
diff = d1 - d0

def summarize(d):
    return {
        "mean": float(d.mean()),
        "ci90": tuple(np.round(np.quantile(d, [0.05, 0.95]), 4)),
        "ci95": tuple(np.round(np.quantile(d, [0.025, 0.975]), 4)),
    }

print({
    "attempt=1": summarize(d1),
    "attempt=0": summarize(d0),
    "diff_mean": float(diff.mean()),
    "Pr(diff>0)": float((diff > 0).mean()),
    "diff_ci95": tuple(np.round(np.quantile(diff, [0.025, 0.975]), 4)),
})

```

## 步骤 A（R → 准备 y 和先验 α, β）

放在 Python 块之前；它只做三件事：从 vdem_change 构造 y（t+1 是否以 coup 收场）、计算经验比例 p0、给出先验强度 m 和 alpha, beta。

```{r}

#| label: r-make-y-and-prior
# 用 regend_t1 构造二元 y：{0,1,2}=1；其它且≠13=0；13(仍存在)丢弃
y <- with(vdem_change, ifelse(regend_t1 %in% c(0,1,2), 1L,
                       ifelse(!is.na(regend_t1) & regend_t1 != 13, 0L, NA_integer_)))
y <- y[!is.na(y)]            # 丢弃 NA
y <- as.integer(y)

# 经验比例（先验中心）
p0 <- mean(y)                # 例如 0.08 左右（你的数据会自动算）
m  <- 20                     # 等效样本量（先小点；后续可调 50/100）
alpha <- m * p0
beta  <- m * (1 - p0)
N <- length(y)

# 小检查
length(y); mean(y); alpha; beta

```

在 R 里和 y 对齐一个自变量 x_attempt（0/1）：

```{r}
# 放在 r-make-y-and-prior 之后
#| label: r-make-x-attempt
library(dplyr)

df_yx <- vdem_change %>%
  mutate(
    y = case_when(
      regend_t1 %in% c(0,1,2) ~ 1L,
      !is.na(regend_t1) & regend_t1 != 13 ~ 0L,
      TRUE ~ NA_integer_
    ),
    x_attempt = case_when(
      !is.na(e_pt_coup_attempts) & e_pt_coup_attempts > 0 ~ 1L,
      !is.na(e_pt_coup_attempts) & e_pt_coup_attempts == 0 ~ 0L,
      TRUE ~ NA_integer_  # ← NA 保留
    )
  ) %>%
  filter(!is.na(y)) %>%
  tidyr::drop_na(x_attempt) %>%
  select(y, x_attempt)

# 传给 Python
y <- as.integer(df_yx$y)
x <- as.integer(df_yx$x_attempt)
N <- length(y)

# 看一下两组样本量（有/无企图）
table(x)

```

把这段放在上面 R 块**后面**即可（它只用到 `r.y_star / r.x_attempt / r.alpha_star / r.beta_star`）。

```{python}
#| label: py-y-star-conditional
import numpy as np
rng = np.random.default_rng(0)

y_star    = np.array(r.y_star, dtype="int64")
x_attempt = np.array(r.x_attempt, dtype="int64")
alpha     = float(r.alpha_star)
beta      = float(r.beta_star)

def group_stats(mask, name):
    y = y_star[mask]
    n = len(y); s = int(y.sum())
    prior_mean = alpha/(alpha+beta)
    post_mean  = (alpha + s)/(alpha + beta + n)
    obs_mean   = y.mean()
    return {"group": name, "n": n,
            "prior_mean": round(float(prior_mean),4),
            "obs_mean":   round(float(obs_mean),4),
            "post_mean":  round(float(post_mean),4)}

out = [group_stats(x_attempt==1, "attempt=1"),
       group_stats(x_attempt==0, "attempt=0")]
print(out)

# 不确定性：后验抽样求区间与差值概率
def post_draws(mask, size=40000):
    y = y_star[mask]
    n = len(y); s = int(y.sum())
    a = alpha + s; b = beta + (n - s)
    return rng.beta(a, b, size=size)

d1 = post_draws(x_attempt==1)
d0 = post_draws(x_attempt==0)
diff = d1 - d0

print({
    "diff_mean": float(diff.mean()),
    "Pr(diff>0)": float((diff>0).mean()),
    "diff_ci95": tuple(np.round(np.quantile(diff, [0.025, 0.975]), 4))
})



```

## 步骤 B（Python → 画PGM并落地成 SVG 包含进 HTML）

```{python}
#| label: py-pgm-beta-bern
import numpy as np, pymc as pm

# 从 R 取数
y = np.array(r.y, dtype="int64")
alpha = float(r.alpha)
beta = float(r.beta)
N = int(r.N)

# 给模型声明 plate
coords = {"obs_id": np.arange(N)}
with pm.Model(coords=coords) as beta_bern:
    # 顶部：Beta先验
    p_coup = pm.Beta("p_coup", alpha=alpha, beta=beta)
    # 底部：观测数据（带 plate）
    y_obs = pm.Bernoulli("saycoup_obs", p=p_coup, observed=y, dims="obs_id")

# 生成 pgm_base.svg 并清理中间文件
pm.model_to_graphviz(beta_bern).render(filename="pgm_base", format="svg", cleanup=True)

```

![](pgm_base.svg)

现在的 baseline **只有一个全局概率** pcoupp\_{\text{coup}}pcoup​，它回答的是：

> “在所有 *会在 t+1 年结束* 的政体中，‘以政变方式结束’的大致占比是多少？”

它**没有**利用任何 t 年的信息（比如是否出现政变企图、内战、抗议等）。因此它**不区分情境**，把所有国家–年都“混在一起”估一个平均值。这对做基线/检查管用，但回答不了这类问题：

-   “当年**有政变企图**时，下一年以政变收场的概率是否更高？”

-   “**内战**的年份 vs 非内战年份，这个概率有什么差异？”

所以要加“条件变量”（covariate），是为了**把总体概率拆成情境化的概率**，也就是从

## 步骤 C（Python → 最小的 prior–posterior 一致性检查：只打印 3 个数字

先不画图、不做复杂评估，只看先验均值 vs 后验均值 vs 观测均值，确认“信息更新”的方向对不对。

```{r}
#| label: opts
#| echo: false
RUN_MCMC <- FALSE 
DRAWS    <- 800
TUNE     <- 400
```

```{python}
#| label: stepC-posterior-check
import numpy as np, pymc as pm

# ——关键：兜底默认值，避免 r.RUN_MCMC 未定义时报错——
RUN_MCMC = bool(getattr(r, "RUN_MCMC", False))
DRAWS    = int(getattr(r, "DRAWS", 800))
TUNE     = int(getattr(r, "TUNE", 400))

y = np.array(r.y, dtype="int64")
alpha = float(r.alpha); beta = float(r.beta)

prior_mean = alpha/(alpha+beta)
obs_mean   = y.mean()

if RUN_MCMC:
    with beta_bern:
        idata = pm.sample(draws=DRAWS, tune=TUNE,
                          chains=2, cores=1, target_accept=0.9,
                          random_seed=42, compute_convergence_checks=False)
    post_mean = float(idata.posterior["p_coup"].values.mean())
    mode = "mcmc"
else:
    N = len(y); s = int(y.sum())
    post_mean = (alpha + s) / (alpha + beta + N)   # Beta–Bernoulli 共轭的解析后验均值
    mode = "analytic"

print({"mode": mode,
       "prior_mean": round(float(prior_mean),4),
       "obs_mean":   round(float(obs_mean),4),
       "post_mean":  round(float(post_mean),4)})


```